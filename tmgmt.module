<?php
/**
 * A new translation job, can not yet be submitted.
 */
define('TMGMT_JOB_STATE_NEW', 0);

/**
 * A prepared translation job, not yet submitted to a translator.
 */
define('TMGMT_JOB_STATE_PREPARED', 1);

/**
 * A translation job that has been submitted to the translator.
 */
define('TMGMT_JOB_STATE_SUBMITTED', 2);

/**
 * A translation job that has been rejected by the translator.
 *
 * The response contains information why the job was rejected.
 */
define('TMGMT_JOB_STATE_REJECTED', 3);

/**
 * The translation job was translated and needs to be reviewed.
 */
define('TMGMT_JOB_STATE_REVIEW', 4);

/**
 * The translation has been accepted and the job is finished.
 */
define('TMGMT_JOB_STATE_ACCEPTED', 5);

/**
 * The translation job has been cancelled.
 */
define('TMGMT_JOB_STATE_CANCELLED', 6);

/**
 * The translation job has been finished.
 */
define('TMGMT_JOB_STATE_FINISHED', 7);

/**
 * String used to delimit flattened array keys.
 */
define('TMGMT_ARRAY_DELIMITER', '][');

/**
 * The selected translator is available for the target language.
 */
define('TMGMT_TRANSLATOR_AVAILABLE', 0);

/**
 * The selected translator is not available yet.
 */
define('TMTGT_TRANSLATOR_NOT_AVAILABLE', 1);

/**
 * The selected translator is not available for the selected language.
 */
define('TMGMT_TRANSLATOR_NOT_AVAILABLE_FOR_LANGUAGE', 2);

/**
 * Implements hook_permission().
 */
function tmgmt_permission() {
  return array(
    'administer tmgmt' => array(
      'title' => t('Administer Translation Management'),
    ),
  );
}

/**
 * Implements hook_entity_info().
 */
function tmgmt_entity_info() {
  $info['tmgmt_job'] = array(
    'label' => t('Translation Management Job'),
    'module' => 'tmgmt',
    'controller class' => 'TMGMTJobController',
    'metadata controller class' => 'TMGMTJobMetadataController',
    'entity class' => 'TMGMTJob',
    'base table' => 'tmgmt_job',
    'uri callback' => 'entity_class_uri',
    'label callback' => 'entity_class_label',
    //'access callback' => 'tmgmt_translator_access',
    'entity keys' => array(
      'id' => 'tjid',
    ),
  );
  $info['tmgmt_job_item'] = array(
    'label' => t('Translation Management Job Item'),
    'module' => 'tmgmt',
    'controller class' => 'EntityAPIController',
    'metadata controller class' => 'TMGMTJobItemMetadataController',
    'entity class' => 'TMGMTJobItem',
    'base table' => 'tmgmt_job_item',
    'uri callback' => 'entity_class_uri',
    'label callback' => 'entity_class_label',
    'entity keys' => array(
      'id' => 'tjiid',
    ),
    'views controller class' => 'TMGMTJobItemViewsController',
  );
  $info['tmgmt_job_message'] = array(
    'label' => t('Translation Management Job Message'),
    'module' => 'tmgmt',
    'controller class' => 'EntityAPIController',
    'metadata controller class' => 'TMGMTJobMessageMetadataController',
    'entity class' => 'TMGMTJobMessage',
    'base table' => 'tmgmt_job_message',
    'uri callback' => 'entity_class_uri',
    'label callback' => 'entity_class_label',
    'entity keys' => array(
      'id' => 'tjmid',
    ),
  );
  $info['tmgmt_translator'] = array(
    'label' => t('Translation Management Translator'),
    'module' => 'tmgmt',
    'controller class' => 'EntityAPIControllerExportable',
    'metadata controller class' => 'TMGMTTranslatorMetadataController',
    'entity class' => 'TMGMTTranslator',
    'base table' => 'tmgmt_translator',
    'exportable' => TRUE,
    // @todo: Fix entity api to check if the entitycache module is enabled.
    // 'entity cache' => TRUE,
    'access callback' => 'tmgmt_translator_access',
    'entity keys' => array(
      'id' => 'tid',
      'name' => 'name',
      'label' => 'label',
    ),
  );
  return $info;
}
/**
 * @addtogroup tmgmt_job
 * @{
 */

/**
 * Loads a translation job.
 */
function tmgmt_job_load($tjid, $reset = FALSE) {
  $jobs = tmgmt_job_load_multiple(array($tjid), array(), $reset);
  return $jobs ? reset($jobs) : FALSE;
}

/**
 * Loads translation jobs.
 */
function tmgmt_job_load_multiple(array $tjids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('tmgmt_job', $tjids, $conditions, $reset);
}

/**
 * Queries the database for all job entities that host a job item that
 * links to a specific source object.
 *
 * @param $source_type
 *   The source type.
 * @param $item_type
 *   The source item type.
 * @param $item_id
 *   The source item id.
 *
 * @return
 *   An array of job entities.
 */
function tmgmt_job_load_multiple_by_source($source_type, $item_type, $item_id) {
  $query = db_select('tmgmt_job', 'tj')->fields('tj', array('tjid'));
  $query->innerJoin('tmgmt_job_item', 'tji', 'tj.tjid = tji.tjid');
  $jobs = $query->execute()->fetchCol();
  if (!empty($jobs)) {
    return tmgmt_job_load_multiple($jobs);
  }
  return array();
}

/**
 * This function will return a job wich matches the requested source- and target
 * language by user. If no job exists, a new job object will be created.
 *
 * @return TMGMTJob
 *  The job entity.
 */
function tmgmt_job_match_item($source_language, $target_language, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }
  $conditions = array('source_language' => $source_language, 'target_language' => $target_language, 'uid' => $account->uid, 'state' => 0);

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'tmgmt_job');
  $query->propertyCondition('source_language', $source_language);
  $query->propertyCondition('target_language', $target_language);
  $query->propertyCondition('uid', $account->uid);
  $query->propertyCondition('state', 0);
  $result = $query->execute();
  if (!empty($result['tmgmt_job'])) {
    return tmgmt_job_load(reset($result['tmgmt_job'])->tjid);
  }
  else {
    return tmgmt_job_create($source_language, $target_language, $account->uid);
  }
}

/**
 * Creates a translation job.
 *
 * @param $source_language
 *   The source language from which should be translated.
 * @param $target_language
 *   The target language into which should be translated.
 * @param $values
 *   (Optional) Array of additional entity values.
 *
 * @return TMGMTJob
 *   The job entity.
 */
function tmgmt_job_create($source_language, $target_language, $uid, array $values = array()) {
  return entity_create('tmgmt_job', array_merge($values, array(
    'source_language' => $source_language,
    'target_language' => $target_language,
    'uid' => $uid,
  )));
}

/**
 * Static method to retrieve a labeled list of all available states.
 *
 * @return array
 *   A list of all available states.
 */
function tmgmt_job_states() {
  return array(
    TMGMT_JOB_STATE_NEW => t('New'),
    TMGMT_JOB_STATE_PREPARED => t('Prepared'),
    TMGMT_JOB_STATE_SUBMITTED => t('Submitted'),
    TMGMT_JOB_STATE_REJECTED => t('Rejected'),
    TMGMT_JOB_STATE_REVIEW => t('Needs review'),
    TMGMT_JOB_STATE_ACCEPTED => t('Accepted'),
    TMGMT_JOB_STATE_CANCELLED => t('Cancelled'),
  );
}
/**
 * @} End of "addtogroup tmgmt_job".
 */

/**
 * Loads a translation job item.
 *
 * @return TMGMTJobItem
 *   The loaded job item.
 */
function tmgmt_job_item_load($tjiid, $reset = FALSE) {
  $jobs = tmgmt_job_item_load_multiple(array($tjiid), array(), $reset);
  return $jobs ? reset($jobs) : FALSE;
}

/**
 * Loads translation job items.
 */
function tmgmt_job_item_load_multiple(array $tjiids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('tmgmt_job_item', $tjiids, $conditions, $reset);
}

/**
 * Creates a translation job item.
 *
 * @param $source_plugin
 *   The plugin name.
 * @param $item_type
 *   The source item type.
 * @param $item_id
 *   The source item id.
 * @param $values
 *   (Optional) An array of additional entity values to be set.
 *
 * @return TMGMTJobItem
 *   The created, not yet saved, job item entity.
 */
function tmgmt_job_item_create($source_plugin, $item_type, $item_id, array $values = array()) {
  return entity_create('tmgmt_job_item', array_merge($values, array(
                    'source_plugin' => $source_plugin,
                    'item_type' => $item_type,
                    'item_id' => $item_id,
                  )));
}

/**
 * This functin will remove a singel item from a job.
 * @param type $tjiid
 */
function tmgmt_job_item_remove($tjiid) {
  return entity_delete('tmgmt_job_item', $tjiid);
}

/**
 * @addtogroup tmgmt_job_message
 * @{
 */

/**
 * Loads a translation job message.
 */
function tmgmt_job_message_load($tjmid, $reset = FALSE) {
  $jobs = tmgmt_job_load_multiple(array($tjmid), array(), $reset);
  return $jobs ? reset($jobs) : FALSE;
}

/**
 * Loads translation job messages.
 */
function tmgmt_job_message_load_multiple(array $tjmids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('tmgmt_job_message', $tjmids, $conditions, $reset);
}

/**
 * Creates a translation job message.
 *
 * @param $status_before
 *   The status before the event occurred.
 * @param $status_after
 *   The status after the event occurred.
 * @param $message
 *   (Optional) The message to be saved.
 * @param $arguments
 *   (Optional) An array of variables to replace in the message on display.
 * @param $values
 *   (Optional) An array of additional entity values to be set.
 *
 * @return TMGMTJobItem
 *   The created, not yet saved, job item entity.
 */
function tmgmt_job_message_create($status_before, $status_after, $message = '', $arguments = array(), $values = array()) {
  return entity_create('tmgmt_job_message', array_merge($values, array(
                    'state_before' => $status_before,
                    'state_after' => $status_after,
                    'message' => $message,
                    'arguments' => $arguments,
                  )));
}
/**
 * @} End of "addtogroup tmgmt_job_message".
 */
/**
 * @addtogroup tmgmt_translator
 * @{
 */

/**
 * Access callback for the translator entity.
 */
function tmgmt_translator_access($op, $translator = NULL, $account = NULL) {
  return user_access('administer tmgmt', $account);
}

/**
 * Loads a translator.
 */
function tmgmt_translator_load($tid, $reset = FALSE) {
  $translators = tmgmt_translator_load_multiple(array($tid), array(), $reset);
  return $translators ? reset($translators) : FALSE;
}

/**
 * Loads a translator based on the name.
 */
function tmgmt_translator_load_by_name($name, $reset = FALSE) {
  $translators = tmgmt_translator_load_multiple(array(), array('name' => $name), $reset);
  return $translators ? reset($translators) : FALSE;
}

/**
 * Loads translation maps.
 */
function tmgmt_translator_load_multiple(array $tids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('tmgmt_translator', $tids, $conditions, $reset);
}

/**
 * Determines all available service plugins.
 *
 * @param $plugin
 *   The machine-readable name of a service plugin.
 */
function tmgmt_translator_plugin_info($plugin = NULL) {
  return _tmgmt_plugin_info('translator', $plugin);
}

/**
 * Determines the controller class for a given service plugin.
 *
 * @param $plugin
 *   The machine-readable name of a service plugin.
 *
 * @return TMGMTTranslatorPluginControllerInterface
 *   The controller object for the given source plugin.
 */
function tmgmt_translator_plugin_controller($plugin) {
  return _tmgmt_plugin_controller('translator', $plugin);
}

/**
 * Returns an array of all available translator plugins with the labels as
 * values and the machine-readable name as the key.
 *
 * @return array
 *   An array of the labels of all available plugins.
 */
function tmgmt_translator_plugin_labels($available_only = FALSE) {
  return _tmgmt_plugin_labels('translator');
}

/**
 * Filters an array of translators and removes those that are not available.
 *
 * @param $plugin array
 */
function tmgmt_translator_availability_filter($plugins) {
  foreach ($plugins as $name => $label) {
    $controller = tmgmt_translator_plugin_controller($name);
    if (!$controller->isAvailable()) {
      unset($plugins[$name]);
    }
  }
  return $plugins;
}

/**
 * @param $plugin
 * @param $source_language
 * @param array $languages
 *   (Optional)
 * @return array
 */
function tmgmt_translator_filtered_by_language($plugins, $source_language, $selected_target_language) {
  foreach ($plugins as $plugin => $label) {
    switch (tmgmt_translator_check($plugin, $source_language, $selected_target_language)) {
      case TMTGT_TRANSLATOR_NOT_AVAILABLE:
        $transator_plugins[$plugin] = t('@label (not available)', array('@label' => $label['label']));
        break;
      case TMGMT_TRANSLATOR_NOT_AVAILABLE_FOR_LANGUAGE:
        $transator_plugins[$plugin] = t('@label (not available for this language)', array('@label' => $label['label']));
        break;
      default:
        $transator_plugins[$plugin] = $label['label'];
    }
  }
  return $transator_plugins;
}

function tmgmt_translator_check($plugin, $source_language, $selected_target_language) {
  $supported_languages[$plugin] = tmgmt_translator_plugin_controller($plugin)->getSupportedTargetLanguages($source_language);
  if (!tmgmt_translator_plugin_controller($plugin)->isAvailable()) {
    return TMTGT_TRANSLATOR_NOT_AVAILABLE;
  }
  elseif (isset($supported_languages[$plugin][$selected_target_language])) {
    return TMGMT_TRANSLATOR_AVAILABLE;
  }
  else {
    return TMGMT_TRANSLATOR_NOT_AVAILABLE_FOR_LANGUAGE;
  }
}

/**
 * Populate translation plugin settings form with default values.
 *
 * @param array $form
 * @param array $form_state
 * @param string $plugin
 *   Translation plugin name.
 * @return array
 *   Form.
 */
function tmgmt_translator_settings_form_defaults($form, &$form_state, $plugin) {
  return system_settings_form($form, $form_state);
}

/**
 * Get plugin translation settings form.
 *
 * @param array $form
 * @param array $form_state
 * @param string $plugin
 *   Translation plugin name.
 */
function tmgmt_translator_settings_form($form, &$form_state, $plugin) {
  $plugin_controller = tmgmt_translator_plugin_controller($plugin);
  $form = $plugin_controller->settingsForm($form, $form_state);
  foreach (element_children($form) as $key) {
    $form['tmgmt_' . $plugin . '_' . $key] = $form[$key];
    unset($form[$key]);
  }
  return $form;
}
/**
 * @} End of "addtogroup tmgmt_translator".
 */
/**
 * @addtogroup tmgmt_source
 * @{
 */

/**
 * Determines all available source object plugins.
 *
 * @param $plugin
 *   The machine-readable name of a source plugin.
 */
function tmgmt_source_plugin_info($plugin = NULL) {
  return _tmgmt_plugin_info('source', $plugin);
}

/**
 * Get the controller class for a given source plugin.
 *
 * @param $plugin
 *   The machine-readable name of a source plugin.
 *
 * @return TMGMTSourcePluginControllerInterface
 *   The controller object for the given source plugin.
 */
function tmgmt_source_plugin_controller($plugin) {
  return _tmgmt_plugin_controller('source', $plugin);
}

/**
 * Returns an array of all available source plugins with the labels as
 * values and the machine-readable name as the key.
 *
 * @return array
 *   An array of the labels of all available plugins.
 */
function tmgmt_source_plugin_labels() {
  return _tmgmt_plugin_labels('source');
}
/**
 * @} End of "addtogroup tmgmt_source".
 */

/**
 * Discovers all available source object plugins.
 *
 * @param $type
 *   The type of the plugin. Can be 'translator' or 'source'.
 * @param $plugin
 *   The machine-readable name of a source plugin.
 */
function _tmgmt_plugin_info($type, $plugin) {
  $info = &drupal_static(__FUNCTION__);
  if (!isset($info[$type])) {
    $info[$type] = array();
    foreach (module_implements('tmgmt_' . $type . '_plugin_info') as $module) {
      foreach (module_invoke($module, 'tmgmt_' . $type . '_plugin_info') as $key => $item) {
        $info[$type][$key] = $item;
        $info[$type][$key]['module'] = $module;
        $info[$type][$key]['plugin'] = $key;
      }
    }
    drupal_alter('tmgmt_' . $type . '_plugin_info', $info);
  }
  if (isset($plugin) && isset($info[$type][$plugin])) {
    return $info[$type][$plugin];
  }
  elseif (!isset($plugin)) {
    return $info[$type];
  }
}

/**
 * Determines the controller class for a given plugin type.
 *
 * @param $type
 *   The type of the plugin. Can be 'translator' or 'source'.
 * @param $plugin
 *   The machine-readable name of a source plugin.
 *
 * @return
 *   The controller object for the given source plugin.
 */
function _tmgmt_plugin_controller($type, $plugin) {
  $cache = &drupal_static(__FUNCTION__);
  if (!isset($cache[$type][$plugin])) {
    $info = _tmgmt_plugin_info($type, $plugin);
    $class = isset($info['controller class']) ? $info['controller class'] : 'TMGMTDefault' . ucfirst($type) . 'PluginController';
    $cache[$type][$plugin] = new $class($plugin);
  }
  return $cache[$type][$plugin];
}

/**
 * Returns an array of labels of all available plugins of a given type with the
 * machine-readable name as the key.
 *
 * @return array
 *   An array of the labels of all available plugins.
 */
function _tmgmt_plugin_labels($type) {
  $list = array();
  $plugin_info = 'tmgmt_' . $type . '_plugin_info';
  foreach ($plugin_info() as $key => $info) {
    $list[$key] = $info['label'];
  }
  return $list;
}

/**
 * Converts a nested data array into a flattened structure with a combined key.
 *
 * This function can be used by translators to help with the data conversion.
 *
 * Nested keys will be joined together using a colon, so for example
 * $data['key1']['key2']['key3'] will be converted into
 * $flattened_data['key1][key2][key3'].
 *
 * @param $data
 *   The nested array structure that should be flattened.
 * @param $prefix
 *   Internal use only, indicates the current key prefix when recursing into
 *   the data array.
 *
 * @return
 *   The flattened data array.
 *
 * @see tmgmt_unflatten_data()
 */
function tmgmt_flatten_data($data, $prefix = NULL) {
  $flattened_data = array();
  // Each element is either a text (has #text property defined) or has children,
  // not both.
  if (!empty($data['#text'])) {
    $flattened_data[$prefix] = $data;
  }
  else {
    $prefix = !empty($prefix) ? $prefix . TMGMT_ARRAY_DELIMITER : '';
    foreach (element_children($data) as $key) {
      $flattened_data += tmgmt_flatten_data($data[$key], $prefix . $key);
    }
  }
  return $flattened_data;
}

/**
 * Converts a flattened data structure into a nested array.
 *
 * This function can be used by translators to help with the data conversion.
 *
 * Nested keys will be created based on the colon, so for example
 * $flattened_data['key1][key2][key3'] will be converted into
 * $data['key1']['key2']['key3'].
 *
 * @param $data
 *   The flattened data array.
 *
 * @return
 *   The nested data array.
 *
 * @see tmgmt_flatten_data()
 */
function tmgmt_unflatten_data($flattened_data) {
  $data = array();
  foreach ($flattened_data as $key => $flattened_data_entry) {
    drupal_array_set_nested_value($data, explode(TMGMT_ARRAY_DELIMITER, $key), $flattened_data_entry);
  }
  return $data;
}
